# Modular program structure

The program consists of several modules (Go packages), each responsible for handling a particular area of the task.

## Processing a FET input file

Only a small subset of these modules is needed for the most basic function of processing a FET input file: `fet`, `autorunner` and `base`.

### Package `base`

This is a very small package providing, primarily, the logging and reporting functions.

### Package `autotimetable`

This package provides the main algorithm for systematically testing various configurations of the input file with different combinations of constraints. It is not inherently dependent on FET, so in principle it could be used with a different timetable-generator back-end. It communicates with the back-end via an interface to maintain this independence.

### Package `fet`

This provides a back-end based on a FET file. It handles regeneration of the FET file with different constraints enabled and starts and monitors the FET process. The FET configuration data is supplied in a particular structure which can be constructed not only from an actual FET input file, but could be produced from some other data.

To handle input from an actual FET file, there is a FET-file reader, which parses a FET input file to produce the structure necessary for the FET back-end.

## Other input sources

To support inputs other than a FET input file there is a collection of packages supporting a fairly simple data structure with all the information necessary for a timetable, and which can be represented as JSON. Being representable as JSON means that this structure can be used as is, or other data can be converted into this structure. This allows other timetable data to be supported by `fetrunner` in a fairly straightforward way.

### Package `db`

This package manages the simple timetable data structure (which I sometimes call the "database"), including functions to assist in conversion from other structures. Only a limited set of constraints is supported at present, which is intentional â€“ the aim is to keep it as simple as possible, whilst supporting enough constraints to make it useful. If necessary, it should be easy enough to add new constraints. 

### Package `timetable`

For building a timetable certain new structures are built from the data in the `db` package which would need rebuilding if any of the underlying data (in `db`) changed. This timetable "preparation" is separated out into the package `timetable`, which is only used when generating or modifying the timetable.

### Package `makefet`

This package builds a FET input file (or, at least, the underlying structure) from the timetable data in the packages `db` and `timetable`. The database structure doesn't support all FET constraints and other features, and the conversion is not 1:1 for all elements, but, in general, the database features can be modelled fairly well in FET. This should not be too surprising as FET was considered as the timetable-generating back-end right from the beginning.

### Package `w365tt`

This package reads a JSON file generated by the `Waldorf 365` program into the database structure in `db`. This allows the `fetrunner` algorithm to be used as a timetable generator for this program. Similar packages could be written to handle data from other software, if the requisite information is available (which it unfortunately often isn't ...).
